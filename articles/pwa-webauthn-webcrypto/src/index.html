<!DOCTYPE html>
<html>
<head>
  <title>Secure Custom Key with WebAuthn</title>
</head>
<body>
  <h2>üîê Store Custom Key Gated by Biometric Auth</h2>
  <textarea id="keyInput" placeholder="Enter your custom key text"></textarea><br>
  <button id="registerBtn">Register Key</button>
  <button id="unlockBtn">Unlock Key (with biometrics)</button>
  <pre id="output"></pre>

  <script>
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    async function aesEncrypt(plaintext, key) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, plaintext);
      return { ciphertext, iv };
    }

    async function aesDecrypt(ciphertext, key, iv) {
      return await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
    }

    async function generateAesKey() {
      return crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
    }

    function bufferToBase64(buf) {
      return btoa(String.fromCharCode(...new Uint8Array(buf)));
    }

    function base64ToBuffer(str) {
      const bin = atob(str);
      return Uint8Array.from(bin, c => c.charCodeAt(0));
    }

    document.getElementById("registerBtn").onclick = async function register() {
      const customText = document.getElementById("keyInput").value;
      const customBytes = encoder.encode(customText);

      const publicKey = {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        rp: { name: "Local Demo" },
        user: {
          id: crypto.getRandomValues(new Uint8Array(16)),
          name: "local-user",
          displayName: "Local User"
        },
        pubKeyCredParams: [{ type: "public-key", alg: -7 }],
        authenticatorSelection: {
          authenticatorAttachment: "platform",
          userVerification: "required"
        },
        timeout: 60000,
        attestation: "none"
      };

      const cred = await navigator.credentials.create({ publicKey });
      const credIdB64 = bufferToBase64(cred.rawId);
      localStorage.setItem("credentialId", credIdB64);

      const aesKey = await generateAesKey();
      const exportedAesKey = await crypto.subtle.exportKey("raw", aesKey);
      const { ciphertext, iv } = await aesEncrypt(customBytes, aesKey);

      localStorage.setItem("wrappedCustomKey", bufferToBase64(ciphertext));
      localStorage.setItem("wrappedIV", bufferToBase64(iv));
      localStorage.setItem("aesKeyWrapped", bufferToBase64(exportedAesKey));

      document.getElementById("output").textContent = "‚úÖ Key registered and encrypted. Use biometrics to unlock.";
    };

    document.getElementById("unlockBtn").onclick = async function unlock() {
      const credIdB64 = localStorage.getItem("credentialId");
      if (!credIdB64) {
        alert("No credential registered!");
        return;
      }

      const assertionOptions = {
        challenge: crypto.getRandomValues(new Uint8Array(32)),
        allowCredentials: [{
          type: "public-key",
          id: base64ToBuffer(credIdB64).buffer,
          transports: ["internal"]
        }],
        userVerification: "required"
      };

      try {
        const assertion = await navigator.credentials.get({ publicKey: assertionOptions });

        const keyData = base64ToBuffer(localStorage.getItem("aesKeyWrapped"));
        const aesKey = await crypto.subtle.importKey("raw", keyData, "AES-GCM", true, ["decrypt"]);

        const ciphertext = base64ToBuffer(localStorage.getItem("wrappedCustomKey"));
        const iv = base64ToBuffer(localStorage.getItem("wrappedIV"));

        const plaintext = await aesDecrypt(ciphertext.buffer, aesKey, iv.buffer);
        document.getElementById("output").textContent = "üîì Decrypted custom key: " + decoder.decode(plaintext);
      } catch (err) {
        document.getElementById("output").textContent = "‚ùå Failed to unlock: " + err.message;
      }
    };
  </script>
</body>
</html>
